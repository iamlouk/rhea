use std::sync::Arc;

use crate::ast::{self, Node};

grammar<'input>(input: &'input str);

pub Program: ast::Program<'input> = {
	<defs: (Definition)*> => {
		ast::Program { defs }
	}
};

Definition: ast::Definition<'input> = {
	TYPE <id: Id> ASSIGN_NEW <typ: Type> SEMICOLON => {
		ast::Definition::Type(id, typ)
	},

	EXTERN <id: Id> ASSIGN_NEW <args: VarArgs> COLON <rettype: Type> SEMICOLON => {
		ast::Definition::Extern(id, ast::Type::Func(Arc::new(
			args.into_iter().map(|e| e.1).collect()), Arc::new(rettype), true))
	},
	EXTERN <id: Id> ASSIGN_NEW <args: Args> COLON <rettype: Type> SEMICOLON => {
		ast::Definition::Extern(id, ast::Type::Func(Arc::new(
			args.into_iter().map(|e| e.1).collect()), Arc::new(rettype), false))
	},
	<id: Id> ASSIGN_NEW <func: Function> SEMICOLON => {
		let mut f = func.node;
		f.name = Some(id);
		ast::Definition::Function(f)
	},
};

Function: Box<Node<'input, ast::Function<'input>>> = {
	<args: VarArgs> COLON <rettype: Type> ARROW <body: Expr> => Node::new(ast::Function {
		name: None, args: args, rettype: rettype, body: body, is_vararg: true
	}),
	<args: Args> COLON <rettype: Type> ARROW <body: Expr> => Node::new(ast::Function {
		name: None, args: args, rettype: rettype, body: body, is_vararg: false
	})
};

Expr: Box<Node<'input, ast::Expr<'input>>> = {
	<a: Logic> => a,
	IF <cond: Logic> <block: Block> ELSE <expr: Expr> =>
		Node::new(ast::Expr::If(cond, block, Some(expr))),
	IF <cond: Logic> <block: Block> => Node::new(ast::Expr::If(cond, block, None)),
	FOR <cond: Logic> <block: Block> => Node::new(ast::Expr::For(None, cond, None, block)),
	FOR <init: Expr> SEMICOLON <cond: Logic> SEMICOLON <inc: Expr> <block: Block> =>
		Node::new(ast::Expr::For(Some(init), cond, Some(inc), block)),
	MUT <id: Id> ASSIGN_NEW <body: Expr> =>
		Node::new(ast::Expr::VarDef(id, ast::VarProp::mutable(), body)),
	<id: Id> ASSIGN_NEW <body: Expr> =>
		Node::new(ast::Expr::VarDef(id, ast::VarProp::default(), body)),
	<lval: Logic> ASSIGN <val: Expr> =>
		Node::new(ast::Expr::Assign(lval, val))
};

Logic: Box<Node<'input, ast::Expr<'input>>> = {
	<a: Logic> AND <b: Condition> => Node::new(ast::Expr::BinaryExpr(a, ast::Operator::And, b)),
	<a: Logic> OR  <b: Condition> => Node::new(ast::Expr::BinaryExpr(a, ast::Operator::Or, b)),
	<a: Condition> => a
};

Condition: Box<Node<'input, ast::Expr<'input>>> = {
	<a: Condition> SMALLER <b: Term> =>
		Node::new(ast::Expr::BinaryExpr(a, ast::Operator::Smaller, b)),
	<a: Condition> EQUAL   <b: Term> =>
		Node::new(ast::Expr::BinaryExpr(a, ast::Operator::Equal, b)),
	<a: Term> => a
};

Term: Box<Node<'input, ast::Expr<'input>>> = {
	<a: Term> ADD <b: Factor> => Node::new(ast::Expr::BinaryExpr(a, ast::Operator::Add, b)),
	<a: Term> SUB <b: Factor> => Node::new(ast::Expr::BinaryExpr(a, ast::Operator::Sub, b)),
	<a: Factor> => a
};

Factor: Box<Node<'input, ast::Expr<'input>>> = {
	<a: Factor> MUL <b: Final> => Node::new(ast::Expr::BinaryExpr(a, ast::Operator::Mul, b)),
	<a: Factor> DIV <b: Final> => Node::new(ast::Expr::BinaryExpr(a, ast::Operator::Div, b)),
	<a: Final> => a
};

Final: Box<Node<'input, ast::Expr<'input>>> = {
	LBRACK <expr: Expr> RBRACK => expr,
	MUL LBRACK <expr: Expr> RBRACK => Node::new(ast::Expr::PtrDeref(expr, 0)),
	MUL <id: Id> => Node::new(ast::Expr::PtrDeref(Node::new(
		ast::Expr::Identifier(id, ast::VarProp::default())), 0)),
	STR => Node::new(ast::Expr::StringLit(<>)),
	REAL => Node::new(ast::Expr::RealLit(<>)),
	INT => Node::new(ast::Expr::IntLit(<>)),
	BOOL => Node::new(ast::Expr::BoolLit(<>)),
	<callee: Final> <args: Tuple> => Node::new(ast::Expr::Call(callee, args)),
	<id: Id> => Node::new(ast::Expr::Identifier(<>, ast::VarProp::default())),
	<arg: Final> AS <typ: Type> => Node::new(ast::Expr::Cast(arg, typ)),
	<block: Block> => block
};

Type: ast::Type<'input> = {
	<id: Id> => {
		match id {
			"Real" => ast::Type::Real,
			"Bool" => ast::Type::Bool,
			"Int" => ast::Type::Int,
			"Char" => ast::Type::Char,
			"Void" => ast::Type::Void,
			id => ast::Type::Unresolved(id)
		}
	},
	MUL <typ: Type> => ast::Type::Ptr(Arc::new(typ)),
	LCBRACK <fields: StructFields> RCBRACK => ast::Type::Struct(Arc::new(fields))
};

StructFields: Vec<(&'input str, ast::Type<'input>)> = {
	<field0: Id> COLON <type0: Type> <fields: (COMMA Id COLON Type)*> => {
		let mut structfields = vec![(field0, type0)];
		for (_, name, _, typ) in fields { structfields.push((name, typ)); }
		structfields
	}
};

Args: Vec<(&'input str, ast::Type<'input>)> = {
	LBRACK <arg0:(Id COLON Type)?> <args:(COMMA Id COLON Type)*> RBRACK => match arg0 {
		Some((i, _, t)) => {
			let mut argvec = vec![(i, t)];
			for (_, i, _, t) in args { argvec.push((i, t)); }
			argvec
		},
		None => Vec::new()
	}
};

VarArgs: Vec<(&'input str, ast::Type<'input>)> = {
	LBRACK <arg0:(Id COLON Type)?> <args:(COMMA Id COLON Type)*> (COMMA)? DOTDOTDOT RBRACK
		=> match arg0 {
		Some((i, _, t)) => {
			let mut argvec = vec![(i, t)];
			for (_, i, _, t) in args { argvec.push((i, t)); }
			argvec
		},
		None => Vec::new()
	}
};

Block: Box<Node<'input, ast::Expr<'input>>> = {
	LCBRACK RCBRACK => ast::Node::new(ast::Expr::Block(vec![])),
	LCBRACK <arg0: Expr> <args: (SEMICOLON Expr)*> (SEMICOLON)? RCBRACK => {
		let mut vec = vec![arg0];
		for (_, arg) in args.into_iter() { vec.push(arg); }
		ast::Node::new(ast::Expr::Block(vec.into_iter().map(|e| *e).collect()))
	}
};

Tuple: Vec<Node<'input, ast::Expr<'input>>> = {
	LBRACK RBRACK => vec![],
	LBRACK <arg0: Expr> <args: (COMMA Expr)*> RBRACK => {
		let mut vec = vec![arg0];
		for (_, arg) in args.into_iter() { vec.push(arg); }
		vec.into_iter().map(|e| *e).collect()
	}
};

Id: &'input str = { ID => <> };

extern {
	type Location = usize;
	type Error = crate::utils::Error;

	enum crate::lexer::Tok<'input> {
		LBRACK => crate::lexer::Tok::LeftBracket,
		RBRACK => crate::lexer::Tok::RightBracket,
		LCBRACK => crate::lexer::Tok::LeftCurlyBracket,
		RCBRACK => crate::lexer::Tok::RightCurlyBracket,
		ASSIGN => crate::lexer::Tok::Assign,
		ASSIGN_NEW => crate::lexer::Tok::AssignNew,
		DOTDOTDOT => crate::lexer::Tok::DotDotDot,
		COMMA => crate::lexer::Tok::Comma,
		COLON => crate::lexer::Tok::Colon,
		ARROW => crate::lexer::Tok::Arrow,
		SEMICOLON => crate::lexer::Tok::Semicolon,
		ADD => crate::lexer::Tok::Add,
		SUB => crate::lexer::Tok::Sub,
		MUL => crate::lexer::Tok::Mul,
		DIV => crate::lexer::Tok::Div,
		AND => crate::lexer::Tok::And,
		OR => crate::lexer::Tok::Or,
		EQUAL => crate::lexer::Tok::Equal,
		SMALLER => crate::lexer::Tok::Smaller,
		IF => crate::lexer::Tok::If,
		ELSE => crate::lexer::Tok::Else,
		FOR => crate::lexer::Tok::For,
		EXTERN => crate::lexer::Tok::Extern,
		MUT => crate::lexer::Tok::Mut,
		AS => crate::lexer::Tok::As,
		STRUCT => crate::lexer::Tok::Struct,
		TYPE => crate::lexer::Tok::Type,
		ID => crate::lexer::Tok::Id(<&'input str>),
		STR => crate::lexer::Tok::Str(<&'input str>),
		INT => crate::lexer::Tok::Int(<i64>),
		REAL => crate::lexer::Tok::Real(<f64>),
		BOOL => crate::lexer::Tok::Bool(<bool>)
	}
}
